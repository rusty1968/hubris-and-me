# I²C Topology Glossary

## Core I²C Terms

**I²C (Inter-Integrated Circuit)**  
Two-wire serial protocol using SCL (clock) and SDA (data) lines. Supports multiple devices on a single bus with 7-bit or 10-bit addressing.

**SCL (Serial Clock Line)**  
Clock signal generated by the master/initiator. All devices on the segment see the same clock.

**SDA (Serial Data Line)**  
Bidirectional data line. Both master and slave can drive it low (open-drain).

**Master/Initiator**  
Device that starts transactions, provides clock, and controls bus direction. Modern specs prefer "initiator."

**Slave/Target**  
Device that responds to master. Address is fixed or configurable. Modern specs prefer "target."

**7-bit Address**  
Standard I²C addressing (0x00-0x7F). Actual bits on wire include R/W bit, making 8 bits total.

**Pull-up Resistors**  
Required resistors (typically 2.2k-10k) pulling SCL/SDA high. Only one set per electrical segment.

## Topology Components

**Controller**  
Physical I²C peripheral in the SoC/MCU (e.g., I2C0, I2C1). Independent hardware block with registers.

**Port**  
Alternative pin mapping for a controller. Some controllers can use different GPIO pins (e.g., I2C2 on PA8/PA9 or PB10/PB11).

The "port" concept in I2C topology is not standard and may cause confusion. We shall clarify what's typically seen in real hardware:

```text
Typical MCU 
├── I2C0 Controller → One set of pins (SCL0/SDA0)
├── I2C1 Controller → One set of pins (SCL1/SDA1)  
├── I2C2 Controller → One set of pins (SCL2/SDA2)
└── I2C3 Controller → One set of pins (SCL3/SDA3)
```

Each I2C controller typically has:

- One physical bus (one SCL/SDA pin pair)
- One clock generator
- One set of control registers

When "Ports" Might Exist

The "port" concept might apply in these specialized cases:

1. Pin Multiplexing (Alternative Functions)

```text
I2C0 Controller:
├── Port 0 → Pins PA9/PA10 (Alternative Function 1)
└── Port 1 → Pins PB6/PB7 (Alternative Function 2)
```
Same controller, different physical pins through GPIO alternate functions.

2. Multi-Channel I2C Controllers (Rare)

```text
Specialized I2C Controller:
├── Channel 0 → SCL0/SDA0 pins
├── Channel 1 → SCL1/SDA1 pins  
└── Channel 2 → SCL2/SDA2 pins
```
One controller block managing multiple independent buses.

3. System-on-Chip with I2C Fabric

```text   
Complex SoC:
├── I2C_FABRIC Controller
│   ├── Port 0 → CPU subsystem bus
│   ├── Port 1 → PCIe subsystem bus
│   └── Port 2 → External connector bus
```

Typical Real-World Scenario
For most embedded systems -> Each controller = One bus = One port

```text
AST1060 MCU:
├── I2C0 → Direct to external pins
├── I2C1 → Direct to external pins
├── I2C2 → Direct to external pins
└── I2C3 → Direct to external pins
```
**Segment**  
Electrically continuous portion of I²C bus. All devices on a segment see all traffic. Limited by capacitance (~400pF).

**Root Segment**  
The segment directly connected to the I²C controller, before any muxes or switches.

**Mux (Multiplexer)**  
I²C-controlled switch connecting upstream to one-of-N downstream segments. Has its own I²C address (e.g., PCA9548A).

**Channel**  
One downstream path of a mux. Terms "channel," "port," and "segment" often used interchangeably for mux outputs.

**Bus**  
Can mean: (1) the entire I²C network from a controller, (2) a single segment, or (3) the protocol itself.

## Electrical Terms

**Capacitance**  
Total capacitive load on segment. Each device adds ~10pF, PCB traces ~2pF/cm. Max ~400pF for standard mode.

**Rise Time**  
Time for signal to go from 30% to 70% of VDD. Limited by pull-up strength and bus capacitance.

**Clock Stretching**  
Slave holding SCL low to slow down master. Not all devices/controllers support this.

**Open-Drain**  
Output type where transistor can only pull low. High state comes from pull-up resistor.

## Protocol Terms

**START Condition**  
SDA falls while SCL is high. Signals beginning of transaction.

**STOP Condition**  
SDA rises while SCL is high. Signals end of transaction.

**Repeated START**  
START without preceding STOP. Used for combined write-then-read operations.

**ACK/NACK**  
Acknowledge (SDA low) or Not-Acknowledge (SDA high) during 9th clock pulse.

**Write-Read Transaction**  
Write register address, then repeated START and read data. Common pattern for register access.

## Address Terms

**Reserved Addresses**  
0x00-0x07 and 0x78-0x7F are reserved by I²C spec for special purposes.

**General Call (0x00)**  
Broadcast address that all devices (that support it) respond to.

**10-bit Address**  
Extended addressing using 0x78-0x7B prefix. Rarely used in practice.

**SMBus Address**  
7-bit address following SMBus rules (some addresses reserved for specific device types).

## Advanced Components

**Switch**  
Like a mux but typically 1:2 or bidirectional. May not provide full isolation.

**Buffer/Repeater**  
Active device that regenerates I²C signals. Allows longer buses or more devices.

**Level Shifter**  
Translates between voltage domains (e.g., 1.8V ↔ 3.3V). May be passive or active.

**Isolator**  
Galvanic isolation using optical or magnetic coupling. Adds latency but provides protection.

## Software Terms

**Lease**  
Software lock/reservation of I²C bus or segment to prevent concurrent access.

**In-band Management**  
Controlling mux selection via I²C commands to the mux itself (vs dedicated select pins).

**Bus Recovery**  
Sequence of clock pulses to unstick a confused device holding SDA low.

**Enumeration**  
Scanning bus to discover which addresses have responding devices.

## Error Conditions

**Bus Locked**  
Device holding SDA low indefinitely, preventing all communication.

**Arbitration Lost**  
Multi-master scenario where one master loses bus control.

**Clock Sync Failure**  
Multi-master scenario where clock synchronization fails.

**Spurious STOP/START**  
Noise or timing violation causing false bus conditions.

## Hubris/Oxide Specific

**Controller Enum**  
Type-safe representation of physical I²C peripheral (I2C0..I2C7).

**Mux Enum (M1-M5)**  
Logical identifier for muxes, decoupled from their I²C addresses.

**Segment Enum (S1-S16)**  
Logical identifier for mux channels/segments.

**ResponseCode**  
Detailed error types for better diagnostics (vs generic "I2C error").

**Mock Controller**  
Software I²C implementation for testing without hardware.


Looking at the Hubeis I2C device type system, here's the topology it supports:

```
┌─────────────────────────────────────────────────────────────────────┐
│                        I2C Topology Model                           │
└─────────────────────────────────────────────────────────────────────┘

Controller Layer (Physical I2C peripherals)
═══════════════════════════════════════════
    I2C0   I2C1   I2C2   I2C3   I2C4   I2C5   I2C6   I2C7   Mock
     │      │      │      │      │      │      │      │       │
     ▼      ▼      ▼      ▼      ▼      ▼      ▼      ▼       ▼

Port Layer (Optional - for controllers with multiple pin options)
═════════════════════════════════════════════════════════════════
     │
     ├─[Port 0]──┐
     ├─[Port 1]──┤  (Only one port active at a time)
     └─[Port N]──┘
            │
            ▼

Root Segment (Direct devices + Muxes)
══════════════════════════════════════
            │
     ┌──────┴──────┬─────────┬──────────┬─────────┐
     │             │         │          │         │
  Device@0x50   Device@0x68  Mux.M1    Mux.M2   Mux.M3
                             @0x70     @0x71    @0x72
                               │         │        │
                               ▼         ▼        ▼

Mux Layer (Up to 5 muxes: M1-M5 per controller)
════════════════════════════════════════════════
                               │
                    ┌──────────┴──────────┐
                    │    Mux.M1 @ 0x70    │
                    └─────────────────────┘
                               │
        ┌──────┬───────┬───────┼───────┬───────┬──────┐
        │      │       │       │       │       │      │
       S1     S2      S3      S4      S5     ...    S16
        │      │       │       │       │             │
        ▼      ▼       ▼       ▼       ▼             ▼

Segment Layer (Up to 16 segments: S1-S16 per mux)
══════════════════════════════════════════════════
        │
   ┌────┴────┬──────────┬──────────┐
   │         │          │          │
Device@0x50 Device@0x51 Device@0x68 ...


Full Path Examples:
═══════════════════
1. Direct device (no mux):
   Controller.I2C2 → [Port] → Device@0x50

2. Device behind single mux:
   Controller.I2C2 → [Port] → Mux.M1 → Segment.S3 → Device@0x68

3. Multiple muxes on same controller:
   Controller.I2C2 → [Port] → ├─ Mux.M1 → S1..S16 → Devices
                              ├─ Mux.M2 → S1..S16 → Devices
                              └─ Mux.M3 → S1..S16 → Devices
```

**Key topology constraints from the types:**

1. **Controllers**: 8 physical I2C controllers (I2C0-I2C7) + Mock for testing

2. **Ports**: Optional layer - some controllers can switch between different pin sets (e.g., I2C2 on pins PA8/PA9 vs PB10/PB11)

3. **Muxes**: Up to 5 muxes (M1-M5) can exist per controller
   - Each mux has its own I2C address on the root segment
   - Muxes are identified by enum, not address (abstraction layer)

4. **Segments**: Up to 16 segments (S1-S16) per mux
   - Each segment is an isolated I2C bus
   - Only one segment active at a time (typical mux behavior)

5. **Addressing**: 
   - Reserved addresses are blocked (0x00-0x07, 0x78-0x7F)
   - Standard 7-bit addressing (no 10-bit support shown)

**What this topology does NOT support:**
- Cascaded muxes (mux behind another mux)
- Multi-level switching beyond single mux layer
- Switches (2:1 or N:1 without full isolation)
- I2C buffers/repeaters as distinct entities

**Typical usage pattern:**
```rust
// Direct device
i2c.write_read(Controller::I2C2, None, 0x50, &[reg], &mut buf)?;

// Device behind mux
i2c.write_read(Controller::I2C2, Some((Mux::M1, Segment::S3)), 0x68, &[reg], &mut buf)?;
```

# I²C Topology Tutorial

## Chapter 1: The Simplest Topology

Let's start with the absolute basics - one controller, one device:

```
MCU/SoC                           Device
┌─────────┐                    ┌─────────┐
│   I2C   │───SCL──────────────│ Sensor  │
│ Master  │───SDA──────────────│ @0x68   │
└─────────┘    │         │     └─────────┘
               │         │
              ┌┴┐       ┌┴┐
              │ │ 4.7k  │ │ 4.7k
              │ │       │ │
              └┬┘       └┬┘
               │         │
              VDD       VDD
```

**Key points:**
- Two wires: SCL (clock) and SDA (data)
- Pull-up resistors required (both lines)
- Device has fixed address (0x68)
- Master initiates all communication

## Chapter 2: Multiple Devices (Single Segment)

Now let's add more devices to the same bus:

```
                     ┌──────────┐
                     │ EEPROM   │
                     │ @0x50    │
                     └────┬─┬───┘
                          │ │
MCU               ┌───────┴─┴────┐      ┌──────────┐
┌─────┐           │               │      │ Temp     │
│ I2C ├──SCL──────┼───────────────┼──────┤ @0x48    │
│     ├──SDA──────┼───────────────┼──────┤          │
└─────┘           │               │      └──────────┘
                  │               │
              ┌───┴─┬───┐    ┌────┴─┬───┐
              │ RTC │   │    │ ADC  │   │
              │ @0x51   │    │ @0x49    │
              └─────────┘    └──────────┘
```

**What works:**
- Each device needs unique address
- All devices see all traffic
- Total capacitance < 400pF
- Shared pull-ups (only one set!)

**What breaks:**
- Two devices with same address
- Too many devices (capacitance)
- Long traces (capacitance)

## Chapter 3: The Address Conflict Problem

You want two identical temperature sensors:

```
MCU
┌─────┐         ┌─────────┐     ┌─────────┐
│ I2C ├─────────┤ Temp #1 │     │ Temp #2 │
│     │         │ @0x48   │     │ @0x48   │  ← CONFLICT!
└─────┘         └─────────┘     └─────────┘
```

**This doesn't work!** Both devices respond to 0x48.

## Chapter 4: Enter the Multiplexer

A mux solves address conflicts by creating isolated segments:

```
                                 Segment 0
                            ┌────┤ Temp #1 @0x48 │
                            │    └───────────────┘
MCU              MUX        │    Segment 1
┌─────┐      ┌─────────┐    ├────┤ Temp #2 @0x48 │
│ I2C ├──────┤ PCA9548 ├────┤    └───────────────┘
│     │      │ @0x70   │    │    Segment 2
└─────┘      └─────────┘    └────┤ Empty         │
                                 └───────────────┘
```

**How to use it:**

```rust
// Step 1: Select mux channel 0
i2c.write(0x70, &[0b00000001])?;  // Enable channel 0

// Step 2: Talk to Temp #1
let temp1 = i2c.read(0x48)?;

// Step 3: Select mux channel 1  
i2c.write(0x70, &[0b00000010])?;  // Enable channel 1

// Step 4: Talk to Temp #2
let temp2 = i2c.read(0x48)?;
```

## Chapter 5: Complex Topology

Real systems combine everything:

```
I2C Controller 0
│
├─[Root Segment]
│  ├─ EEPROM @0x50          (System config)
│  ├─ RTC @0x51             (Time keeping)
│  │
│  ├─ MUX_A @0x70           (Sensor isolation)
│  │  ├─[Ch0]─ Temp @0x48   (CPU0 temp)
│  │  ├─[Ch1]─ Temp @0x48   (CPU1 temp)
│  │  └─[Ch2]─ Temp @0x48   (Ambient)
│  │
│  └─ MUX_B @0x71           (Power monitoring)
│     ├─[Ch0]─ INA219 @0x40 (12V rail)
│     ├─[Ch1]─ INA219 @0x40 (5V rail)
│     └─[Ch2]─ INA219 @0x40 (3.3V rail)
│
I2C Controller 1
│
└─[Root Segment]
   ├─ MUX_C @0x72           (Hot-plug slots)
   │  ├─[Ch0]─ [Empty/Unknown devices]
   │  ├─[Ch1]─ [Empty/Unknown devices]
   │  └─[Ch2]─ [Empty/Unknown devices]
   │
   └─ GPIO Expander @0x20   (Mux reset control)
```

## Chapter 6: Electrical Considerations

### Capacitance Budget

Each segment has a capacitance limit:

```
Device capacitance:     ~10pF each
PCB trace capacitance:  ~2pF/cm
Cable capacitance:      ~50-100pF/m

Standard mode (100kHz): 400pF max
Fast mode (400kHz):     400pF max  
Fast mode+ (1MHz):      550pF max
```

### Pull-up Calculation

```
Minimum (strongest): VDD / 3mA
Maximum (weakest):   Rise time / (0.8473 × C)

Example for 3.3V, 400pF bus:
- Minimum: 3.3V / 3mA = 1.1kΩ
- Maximum: 1000ns / (0.8473 × 400pF) = 2.95kΩ
- Typical choice: 2.2kΩ
```

### Segment Isolation

Why muxes provide isolation:

```
Without Mux:                  With Mux:
Total C = C1+C2+C3+C4        Total C = C_root + C_active_segment

     400pF                         100pF      100pF
  (all devices)                  (root)    (segment)
```

## Chapter 7: Software Patterns

### Basic Mux Control

```rust
struct MuxI2C {
    bus: I2cBus,
    mux_addr: u8,
}

impl MuxI2C {
    fn select_channel(&mut self, ch: u8) -> Result<()> {
        // PCA9548: bit position = channel
        self.bus.write(self.mux_addr, &[1 << ch])
    }
    
    fn read_device(&mut self, ch: u8, addr: u8) -> Result<u8> {
        self.select_channel(ch)?;
        self.bus.read(

This is a pragmatic model that covers most server/embedded topologies while avoiding the complexity of arbitrary tree structures.
